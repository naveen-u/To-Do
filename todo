#!/usr/bin/env python3

#-------------------------------------------------------------------------------
# Name:        To-do List
# Purpose:     Maintain a command-line to-do list
# Author:      Naveen Unnikrishnan
# Created:     03/07/2018
#-------------------------------------------------------------------------------

__author__ = 'Naveen Unnikrishnan'
__version__ = 1.2

import argparse
import json
import os
import datetime
import re

import sys
import time
import atexit
import math
import random
from signal import signal, SIGPIPE, SIG_DFL

PY3 = sys.version_info >= (3,)

# override default handler so no exceptions on SIGPIPE
signal(SIGPIPE, SIG_DFL)

# Reset terminal colors at exit
def reset():
    sys.stdout.write('\x1b[0m')
    sys.stdout.flush()

atexit.register(reset)

STRIP_ANSI = re.compile(r'\x1b\[(\d+)(;\d+)?(;\d+)?[m|K]')
COLOR_ANSI = (
    (0x00, 0x00, 0x00), (0xcd, 0x00, 0x00),
    (0x00, 0xcd, 0x00), (0xcd, 0xcd, 0x00),
    (0x00, 0x00, 0xee), (0xcd, 0x00, 0xcd),
    (0x00, 0xcd, 0xcd), (0xe5, 0xe5, 0xe5),
    (0x7f, 0x7f, 0x7f), (0xff, 0x00, 0x00),
    (0x00, 0xff, 0x00), (0xff, 0xff, 0x00),
    (0x5c, 0x5c, 0xff), (0xff, 0x00, 0xff),
    (0x00, 0xff, 0xff), (0xff, 0xff, 0xff),
)

class LolCat(object):
    def __init__(self, mode=256, output=sys.stdout):
        self.mode =mode
        self.output = output

    def _distance(self, rgb1, rgb2):
        return sum(map(lambda c: (c[0] - c[1]) ** 2,
            zip(rgb1, rgb2)))

    def ansi(self, rgb):
        r, g, b = rgb

        if self.mode in (8, 16):
            colors = COLOR_ANSI[:self.mode]
            matches = [(self._distance(c, map(int, rgb)), i) for i, c in enumerate(colors)]
            matches.sort()
            color = matches[0][1]

            return '3%d' % (color,)
        else:
            gray_possible = True
            sep = 2.5

            while gray_possible:
                if r < sep or g < sep or b < sep:
                    gray = r < sep and g < sep and b < sep
                    gray_possible = False

                sep += 42.5

            if gray:
                color = 232 + int(float(sum(rgb) / 33.0))
            else:
                color = sum([16]+[int(6 * float(val)/256) * mod
                    for val, mod in zip(rgb, [36, 6, 1])])

            return '38;5;%d' % (color,)

    def wrap(self, *codes):
        return '\x1b[%sm' % (''.join(codes),)

    def rainbow(self, freq, i):
        r = math.sin(freq * i) * 127 + 128
        g = math.sin(freq * i + 2 * math.pi / 3) * 127 + 128
        b = math.sin(freq * i + 4 * math.pi / 3) * 127 + 128
        return [r, g, b]

    def cat(self, fd, options):
        for line in fd:
            options.seed += 1
            self.println(line, options)

    def println(self, s, options):
        s = s.rstrip()
        if options.force or self.output.isatty():
            s = STRIP_ANSI.sub('', s)

        self.println_plain(s, options)

        self.output.write('\n')
        self.output.flush()

    def println_plain(self, s, options):
        for i, c in enumerate(s if PY3 else s.decode(options.charset_py2, 'replace')):
        	rgb = self.rainbow(options.freq, options.seed + i / options.spread)
        	self.output.write(''.join([self.wrap(self.ansi(rgb)), c if PY3 else c.encode(options.charset_py2, 'replace')]))

def detect_mode(term_hint='xterm-256color'):
    '''
    Poor-mans color mode detection.
    '''
    if 'ANSICON' in os.environ:
        return 16
    elif os.environ.get('ConEmuANSI', 'OFF') == 'ON':
        return 256
    else:
        term = os.environ.get('TERM', term_hint)
        if term.endswith('-256color') or term in ('xterm', 'screen'):
            return 256
        elif term.endswith('-color') or term in ('rxvt',):
            return 16
        else:
            return 256 # optimistic default

def makeBlankTodo():
	'''
	Makes an empty to-do list file.
	'''
	with open(todoFile,'w') as file:
		json.dump(todo,file)

def printTodo(todo, ids, verbose, searchTags, options, enable_lolcat=False):
	'''
	Prints the todo list.
	'''
	print()
	to_print = "TO-DO LIST".center(os.get_terminal_size().columns) + '\n' + '='*os.get_terminal_size().columns + '\n' + '\n'
	if len(todo['list']) == 0:
		to_print = to_print + '\tYour todo list is empty!\n'
	else:
		j = 1
		for i in ids:
			skip = False
			if searchTags is not None:
				for tag in searchTags:
					tag = tag.lower()
					if tag not in todo['tags'][i[1]]:
						skip = True
						break
			if skip:
				continue
			if i[0] == 1:
				s = '\u2757 \u2B50\t'
			elif i[0] == 2:
				s = '\u2757\t'
			elif i[0] == 3:
				s = '\u2B50\t'
			else:
				s = '\t'
			s += str(j) + ') '
			if verbose and todo['tags'][i[1]] != []:
				s += ', '.join(todo['tags'][i[1]])
				s += ' : '
			s += todo['list'][i[1]]
			to_print = to_print + s + '\n'
			j = j+1

	if not enable_lolcat:
		print(to_print)
	else:
		lolcat = LolCat(mode=options.mode)
		to_print_list = to_print.split('\n')
		lolcat.cat(to_print_list, options)

def addItem(todoFile, todo, item, priority, tags):
	'''
	Add item(s) to the todo list
	'''
	try:
		with open(todoFile,'w') as jsonFile:
			item = ' '.join(item)
			item = item.split('^')
			for i in item:
				i = i.strip()
				timestamp = datetime.datetime.now().strftime('%Y%m%d%H%M%S%f')
				todo['list'][timestamp] = i
				todo['priority'][timestamp] = priority
				todo['tags'][timestamp] = []
				if tags is not None:
					todo['tags'][timestamp] = [x.lower() for x in tags]
					todo['tags'][timestamp] = sorted(todo['tags'][timestamp])
			json.dump(todo, jsonFile, indent=4)
	except:
		print('Oops! Something went wrong when adding that to your todo list.')

def deleteItem(todoFile, todo, idx, ids, delTags):
	'''
	Delete item(s) from todo list
	'''
	length = len(todo['list'])
	idx = ' '.join(idx)
	if re.search(r'[^\s0-9-]', idx) is not None:
		x = input("Your contains characters that are not numbers, white spaces or dashes. Continuing might result in unexpected behaviour. Continue? [y/n]\t")
		if(x == 'n'):
			return
	idx = re.split(r"[^-0-9]", idx)
	idx = list(filter(None, idx))
	result = []
	for part in idx:
		try:
			if '-' in part:
				a, b = part.split('-')
				if representsInt(a) and representsInt(b):
					a, b = int(a), int(b)
					result.extend(range(a, b + 1))
				elif representsInt(a):
					a = int(a)
					result.append(a)
				elif representsInt(b):
					b = int(b)
					result.append(b)
			else:
				a = int(part)
				result.append(a)
		except:
			print('Oops! Something went wrong when processing '+ str(part) +'.')
	idx = result
	if delTags is not None:
		for tag in delTags:
			for i in range(len(ids)):
				if tag in todo['tags'][ids[i][1]]:
					if i+1 not in idx:
						idx.append(i+1)
	idx = sorted(idx, key=int, reverse=True)
	for i in idx:
		try:
			i = int(i)
			if i > length:
				continue
			del(todo['list'][ids[i-1][1]])
			del(todo['priority'][ids[i-1][1]])
			del(todo['tags'][ids[i-1][1]])
			del(ids[i-1])
		except:
	 		print('Oops! Something went wrong when deleting entry ' + str(i) +'.')
	with open(todoFile,'w') as jsonFile:
		json.dump(todo, jsonFile, indent=4)

def representsInt(s):
    try: 
        int(s)
        return True
    except ValueError:
        return False

if __name__ == '__main__':
	# Setting up command-line arguments
	parser = argparse.ArgumentParser(prog = 'todo', description = 'Create and maintain a to-do list.')
	parser.add_argument('--suppress', '-s', help = "Don't display todo-list after action.", action = 'store_true')
	parser.add_argument('--verbose', '-v', help = "Display tags along with items in todo-list.", action = 'store_true')	
	parser.add_argument('--tag', '-t', nargs='*', help = 'Tag(s) to be searched for.', dest = 'tag_main')
	subparsers = parser.add_subparsers(dest = 'command')

	parser_a = subparsers.add_parser('add', help = 'Add new item(s) to to-do list.')
	parser_a.add_argument('item', nargs='*', help = 'Item(s) to be added to to-do list.')
	parser_a.add_argument('--urgent', '-u', help = "Flag the item as urgent.", action = 'store_true')
	parser_a.add_argument('--important', '-i', help = "Flag the item as important.", action = 'store_true')
	parser_a.add_argument('--tag', '-t', nargs='*', help = 'Tag(s) to be added to item(s).', dest = 'tag_add')

	parser_d = subparsers.add_parser('del', help = 'Delete item(s) from to-do list.')
	parser_d.add_argument('id', nargs='*', help='S.no(s). of item(s) to be deleted from to-do list.')
	parser_d.add_argument('--tag', '-t', nargs='*', help = 'Tag(s) to be deleted.', dest = 'tag_del')

	parser_c = subparsers.add_parser('clear', help = 'Clear to-do list.')

	parser_d = subparsers.add_parser('lolcat', help = 'Display message as lolcat',)
	parser_d.add_argument('--seed', '-S', help = "Rainbow seed", type = int, default = 0, dest = 'seed')
	parser_d.add_argument('--spread', '-p', help = "Rainbow spread", type = float, default = 3.0, dest = 'spread')
	parser_d.add_argument('--frequency', '-F', help = "Rainbow frequency", type = float, default = 0.1, dest = 'freq')
	parser_d.add_argument('--force', '-f', help = "Force colour even when stdout is not a tty", action = 'store_false')

	parser_d.add_argument('-3', action = 'store_const', dest = 'mode', const = 8, help = 'Force 3 bit colour mode')
	parser_d.add_argument('-4', action = 'store_const', dest = 'mode', const = 16, help = 'Force 4 bit colour mode')
	parser_d.add_argument('-8', action = 'store_const', dest = 'mode', const = 256, help = 'Force 8 bit colour mode')

	args = parser.parse_args()

	# Initializing variables
	todoFile = os.path.join(os.environ['HOME'],'.todo.json')
	todo = {}
	todo['list'] = {}
	todo['priority'] = {}
	todo['tags'] = {}
	ids = []

	# Check if todo file exists
	if os.path.isfile(todoFile) is False:
		makeBlankTodo()

	# Clear command
	if args.command == 'clear':
		makeBlankTodo()

	# Reading current to-do list
	try:
		with open(todoFile,'r') as jsonFile:
			todo = json.load(jsonFile)
	except:
		print('Awww snap! Looks like someone has messed up your todo file. All your existing data will be lost!')
		makeBlankTodo()

	# Add item(s)
	if args.command == 'add' and args.item != []:
		priority = 4
		if args.urgent == True:
			priority -= 2
		if args.important == True:
			priority -= 1
		addItem(todoFile, todo, args.item, priority, args.tag_add)

	# Get IDs and sort
	for i in todo['priority']:
		ids.append((todo['priority'][i],i))
	ids = sorted(ids, key=lambda x: x[1])
	ids = sorted(ids, key=lambda x: x[0])

	# Delete item(s)
	if args.command == 'del' and (args.id != [] or args.tag_del != []):
		deleteItem(todoFile, todo, args.id, ids, args.tag_del)

	# Supress display after adding/deleting/clearing
	if args.suppress is None or args.suppress is False:
		if args.command == 'lolcat':
			if args.spread == 0.0:
				args.spread = 3.0
			args.mode = args.mode or detect_mode()
			args.seed = random.randint(0, 256) if args.seed == 0 else args.seed
			printTodo(todo, ids, args.verbose, args.tag_main, args, enable_lolcat=True)
		else:
			printTodo(todo, ids, args.verbose, args.tag_main, args)